# **************************************************  دستورات خط فرمان (CMD) **************************************
"""
IN CMD :
python --version ==> اطمینان از نصب پایتون در سیستم
dir ==> فایل‌های موجود در آدرسی که هست را نشان می‌دهد.
cd name ==> وارد فایل مورد نظر می‌شود
cd .. ==> از فایل الان یک واحد بر می‌گردد
python نام_فایل.py ==> بعد از اینکه به مسیر فایل پایتون رسیدید، این دستور را وارد کنید
"""
# ************************************** پیشنهادات توسعه‌دهندگان پایتون (PEP) ******************************************
"""
(PEP مخفف Python Enhancement Proposal)
PEP8       ==> استانداردهای کدنویسی تمیز و خوانا
PEP 634    ==> Pattern Matching
PEP 572    ==> Assignment Expressions (:=)
PEP 612, 695 ==> Type Hinting Improvements
PEP 701    ==> F-strings Improvements
"""
# *************************************** قوانین نام‌گذاری متغیرها *************************************************
"""
Rules for variable names  
(قوانین نام‌گذاری متغیرها

names can not start with a number  
نام‌ها نمی‌توانند با عدد شروع شوند

names can not contain spaces, use _ instead  
نام‌ها نمی‌توانند فاصله خالی داشته باشند، به جای آن از _ استفاده کنید

names can not contain any of these symbols:  
نام‌ها نمی‌توانند شامل هیچ‌کدام از این نمادها باشند:
{ : ' " , < > / ? | \ ! @ # % ^ & * ~ - + }

it's considered best practice (PEP8) that names are lowercase with underscores  
مطابق با بهترین روش‌های توصیه‌شده (PEP8)، نام‌ها باید با حروف کوچک و با خط زیر (underscore) نوشته شوند

avoid using Python built-in keywords like list and str  
از استفاده از کلمات کلیدی داخلی پایتون مانند list و str خودداری کنید

avoid using the single characters l (lowercase letter el)
, O (uppercase letter oh) and I (uppercase letter eye) as they can be confused with 1 and 0)  
از استفاده از تک حروف l (حرف کوچک ال)، O (حرف بزرگ او) و I (حرف بزرگ آی) خودداری کنید،
 زیرا ممکن است با اعداد ۱ و ۰ اشتباه شوند
"""
# ***************************************** نوع‌دهی پویا (Dynamic Typing) ************************************************
"""
نوع‌دهی پویا (Dynamic Typing)
در زبان پایتون، از نوع‌دهی پویا استفاده می‌شود. 
این بدین معناست که شما می‌توانید یک متغیر را به انواع مختلف داده‌ها مقداردهی کنید 
و نیازی نیست که نوع متغیر را از قبل مشخص کنید.
 این ویژگی پایتون را بسیار انعطاف‌پذیر و کاربرپسند می‌کند،
  به خصوص در مقایسه با زبان‌های دیگری مثل C، C++ یا Java که از نوع‌دهی ایستا (Static Typing) استفاده می‌کنند 
 (یعنی نوع متغیر هنگام تعریف باید مشخص شود و تغییر نمی‌کند).
"""
my_dogs = 2  # در اینجا، متغیر my_dogs عدد صحیح 2 را دارد.
my_dogs = ['Sammy', 'Frankie']  # حالا my_dogs دیگر یک عدد نیست، بلکه یک لیست از رشته‌ها است.

"""
مزایا و معایب نوع‌دهی پویا :
✅ مزایای نوع‌دهی پویا
کار کردن با آن بسیار آسان است:
نیازی نیست هر بار قبل از استفاده از متغیر، نوع آن را تعریف کنید. کد شما کوتاه‌تر و خوانا‌تر می‌شود.

سرعت توسعه بالاتر:
برنامه‌نویسان می‌توانند سریع‌تر کد بنویسند،
 چون نیازی به تعریف صریح نوع داده‌ها نیست و می‌توانند متغیرها را آزادانه تغییر دهند.

❌ معایب نوع‌دهی پویا

احتمال بروز باگ‌های غیرمنتظره:
چون متغیرها می‌توانند در طول برنامه نوع خود را تغییر دهند،
 ممکن است جایی که انتظار دارید یک عدد داشته باشید، یک رشته یا لیست دریافت کنید.
 این موضوع می‌تواند باعث خطا در محاسبات یا اجرای برنامه شود.

نیاز به توجه بیشتر به نوع داده‌ها:
شما باید همیشه مراقب باشید که چه نوع داده‌ای در یک متغیر قرار دارد،
 چون پایتون به صورت خودکار نوع را کنترل نمی‌کند. این مسئولیت بر عهده خود برنامه‌نویس است.
"""
# ******************************************** تخصیص متغیرها (Assigning Variables) ****************************************
"""
تخصیص متغیرها (Assigning Variables)
در زبان پایتون، متغیرها با استفاده از ساختار نام = مقدار مقداردهی می‌شوند.
 در این ساختار، علامت مساوی (=) یک عملگر تخصیص (assignment operator) است، نه نماد تساوی ریاضی.
"""
a = 5
"""
در اینجا، عدد صحیح 5 به متغیری به نام a تخصیص داده شده است.
حالا a نماینده عدد ۵ است.
"""
print("a + a =", a + a)  # این عبارت یعنی: 5 + 5 = 10

"""
به یاد داشته باشید: متغیرها مثل "برچسب" روی یک مقدار داده هستند. 
وقتی مقدار متغیر را تغییر می‌دهید، 
در واقع برچسب را به یک مقدار جدید منتقل کرده‌اید(محتوای برچسب را عوض کردید). 
"""
# *************************************** تغییر مجدد مقدار متغیرها (Reassigning Variables) ********************************
"""
تغییر مجدد مقدار متغیرها (Reassigning Variables)
در پایتون، می‌توانید یک متغیر را دوباره مقداردهی کنید (یعنی مقدار جدیدی به آن اختصاص دهید)
 با استفاده از مقدار قبلی خودش.
این کار با ارجاع به همان متغیر انجام می‌شود.
"""
a = 10
a = a + 10  # a = 20
"""
این دستور یعنی:
مقدار فعلی a را بگیر (یعنی ۱۰)
با ۱۰ جمع کن (می‌شود ۲۰)
نتیجه را دوباره به a نسبت بده
"""
print("a =", a)  # نمایش مقدار جدید a

"""
عملگرهای کوتاه‌برد (Shorthand Operators)
پایتون راهی کوتاه‌تر و سریع‌تر برای انجام این کار فراهم کرده است.
این عملگرها به شما اجازه می‌دهند که جمع، تفریق، ضرب و تقسیم را با تخصیص مجدد به صورت خلاصه بنویسید.
+=   ==> جمع و تخصیص مجدد
-=   ==> تفریق و تخصیص مجدد
*=   ==> ضرب و تخصیص مجدد
/=   ==> تقسیم و تخصیص مجدد
"""
a += 10  # a = 30
print("a += 10 => a =", a)
a *= 2   # a = 60
print("a *= 2 => a =", a)

"""
چرا این کوتاه‌نویسی مفید است؟
کد شما خوانا و کوتاه‌تر می‌شود.
کمتر احتمال خطا دارد (چون نیازی نیست دو بار نام متغیر را بنویسید).
در برنامه‌نویسی روزمره بسیار رایج و مرسوم است.
"""
# ******************************************** تعیین نوع متغیر با تابع type() ************************************************
"""
تعیین نوع متغیر با تابع type()
در پایتون، از تابع داخلی type() برای بررسی نوع داده‌ای که به یک متغیر تخصیص داده شده استفاده می‌شود.
این تابع به شما کمک می‌کند بفهمید یک متغیر چه نوعی از داده را نگه می‌دارد — مثلاً عدد صحیح، عدد اعشاری، رشته، لیست و غیره.
type(نام_متغیر)
"""
"""
Types :
int (اعداد صحیح), float (اعداد اعشاری), str (رشته), list, tuple, dict, set, bool (درست و نادرست)
"""
a = 10
print("type(a) =", type(a))  # <class 'int'>

name = "Ali"
print("type(name) =", type(name))  # <class 'str'>

"""
چرا type() مهم است؟
چون پایتون نوع‌دهی پویا دارد، یک متغیر می‌تواند در طول برنامه انواع مختلفی از داده‌ها را داشته باشد.
با استفاده از type() می‌توانید از نوع داده اطمینان حاصل کنید و از خطا در محاسبات یا عملیات جلوگیری کنید.
"""
# *********************************************************** انواع اعداد در پایتون ***********************************
"""
: انواع اعداد در پایتون
پایتون سه نوع عددی اصلی دارد:

int
عدد صحیح
42 , -7 , 0

float
عدد اعشاری (مایل به شناور)
3.14, -0.001, 2e5

complex
عدد مختلط
3+4j, 1.5-2.7j

🔍 نکته: 
bool (مقادیر True و False) زیرمجموعه‌ای از int است.
True == 1 و False == 0 (هرچند بهتر است صریحاً تبدیل کنید: int(True) → 1)
"""
# *****************************************************  int — اعداد صحیح  ****************************************
"""
int — اعداد صحیح
بدون بخش اعشاری.
دقت نامحدود (unlimited precision):
"""
big_num = 10**100  # عدد بسیار بزرگ — بدون مشکل!
print("big_num =", big_num)  # 10000000000000000000000000000000...

# *******************************************************  float — اعداد اعشاری  ****************************************
"""
float — اعداد اعشاری
اعدادی با نقطه اعشار یا نماد علمی (e یا E).
بر اساس استاندارد IEEE 754 پیاده‌سازی می‌شوند (معمولاً double-precision).
دقت محدود دارند و ممکن است خطاهای گرد کردن داشته باشند:
"""
print("0.1 + 0.2 == 0.3:", 0.1 + 0.2 == 0.3)  # False! چون 0.1 + 0.2 = 0.30000000000000004
print("float('inf') =", float('inf'))   # بی‌نهایت مثبت
print("float('-inf') =", float('-inf'))  # بی‌نهایت منفی
print("float('nan') =", float('nan'))   # Not a Number (عدد نیست)

# *******************************************************  complex — اعداد مختلط  ********************************************
"""
complex — اعداد مختلط
دارای بخش حقیقی و موهومی (j برای واحد موهومی).
"""
z = 3 + 4j
print("z.real =", z.real)  # 3.0
print("z.imag =", z.imag)  # 4.0

# *************************************************  عملیات‌های پایه ریاضی  **********************************************
"""
عملیات‌های پایه ریاضی

+ جمع
5 + 3

- تفریق
9 - 2

* ضرب
2 * 6

/ تقسیم اعشاری
7 / 2
3.5

//   تقسیم کف (صحیح)
7 // 2
3

%   باقی‌مانده (Modulo)
7 % 2

**  توان
2 ** 3

-x  قرینه
-5

+x  علامت مثبت (بی‌اثر)
+5
"""
# ********************************************************  تقسیم کف (Floor Division)  **************************************
"""
تقسیم کف (Floor Division)
نتیجه را به سمت پایین (کمترین عدد صحیح) گرد می‌کند.
برای اعداد مثبت شبیه تقسیم صحیح است.
برای اعداد منفی، به سمت منفی بی‌نهایت می‌رود.
"""
print("7 // 4 =", 7 // 4)  # → 1
print("-7 // 4 =", -7 // 4)  # → -2

# *****************************************************  توان و ریشه  *********************************************
"""
توان:
2 ** 3       # → 8
10 ** 6      # → 1000000

ریشه:
ریشه دوم: x ** 0.5
ریشه سوم: x ** (1/3)
ریشه nام: x ** (1/n)

4 ** 0.5     # → 2.0
8 ** (1/3)   # → 2.0

پایتون 0 ** 0 را برابر با 1 تعریف می‌کند (مثل اکثر زبان‌های برنامه‌نویسی). 
"""
print("2 ** 3 =", 2 ** 3)  # → 8
print("4 ** 0.5 =", 4 ** 0.5)  # → 2.0

# *************************************************  ترتیب اولویت عملگرها (Order of Operations)  ********************************************
"""
ترتیب اولویت عملگرها (Order of Operations)
پایتون از قانون PEMDAS پیروی می‌کند:

P — پرانتز ()
E — توان **
M/D — ضرب و تقسیم (چپ به راست)
A/S — جمع و تفریق (چپ به راست)

2 + 3 * 4 ** 2
# = 2 + 3 * 16
# = 2 + 48
# = 50

(2 + 3) * (4 + 1)  # → 5 * 5 = 25
پرانتز فقط برای اولویت نیست، بلکه کد را خوانا‌تر می‌کند. 
"""

a = 5
b = a
a = a + 1
print("b =", b)  # هنوز 5 است — چون b به شیء اصلی اشاره دارد

# ********************************************  ماژول‌های عددی پیشرفته  **********************************************
"""
fractions.Fraction — کسرها بدون خطای اعشاری
"""
from fractions import Fraction
f = Fraction(1, 3)
print("f * 3 =", f * 3)  # → Fraction(1, 1) → 1

"""
decimal.Decimal — اعداد اعشاری دقیق (برای محاسبات مالی)
"""
from decimal import Decimal
a1 = Decimal('0.1')
b1 = Decimal('0.2')
print("a1 + b1 =", a1 + b1)  # → Decimal('0.3') — بدون خطا!

"""
complex — اعداد مختلط
"""
z = 3 + 4j
print("abs(z) =", abs(z))        # → 5.0 (قدر مطلق)
print("z.conjugate() =", z.conjugate()) # → (3-4j)

# *************************************************  ایجاد رشته‌ها  *********************************************
"""
در پایتون، رشته با قرار دادن متن درون علامت نقل قول تکی (' ') یا دوبل (" ") ایجاد می‌شود.
"""
# با گیومه تکی
'سلام دنیا'

# با گیومه دوبل
"Hello World"

# رشته خالی
''

"""
تفاوت گیومه تکی و دوبل؟
هیچ تفاوت عملی ندارند. فقط وقتی یکی از آن‌ها درون متن استفاده شود، از دیگری برای احاطه کردن استفاده کنید.

'I'm a programmer'  # ❌ خطای نحوی
علامت ' در I'm باعث می‌شود پایتون فکر کند رشته تمام شده است.

"Now I'm ready to use single quotes!"  # ✅
'I\'m a programmer'                   # ✅ با استفاده از `\` (ایسکیپ)
"Use \"double quotes\" inside strings" # ✅
"""

# رشته‌های چندخطی (Triple Quotes)
text = """این یک رشته
چند خطی است
که فاصله‌ها و خطوط جدید را حفظ می‌کند."""
print("text =", text)

# *********************************************  چاپ رشته‌ها *****************************************************
print('Hello World 1')  # چاپ رشته ساده
print('Hello World 2')  # چاپ رشته ساده

# ****************************************************  کاراکترهای کنترلی (Escape Sequences) **********************************************
"""
\n
خط جدید

\t
تب (Tab)

\\
خود کاراکتر بک‌اسلش

\'
گیومه تکی

\"
گیومه دوبل
"""
print("Use \\n to create a new line")  # نمایش کاراکتر \n به صورت متن
print("Name:\tAli")  # استفاده از تب

# ******************************************** اندیس‌گذاری و برش رشته‌ها ******************************************
# رشته‌ها در پایتون دنباله‌ای از کاراکترها هستند. هر کاراکتر یک اندیس (index) دارد که از صفر شروع می‌شود.
s = 'Hello World'
print("s[0] =", s[0])    # → 'H'
print("s[1] =", s[1])    # → 'e'
print("s[-1] =", s[-1])   # → 'd' (آخرین کاراکتر)
print("s[-2] =", s[-2])   # → 'l'

"""
برش رشته (Slicing)
فرمت: s[شروع:پایان:گام] 

شروع: اندیس شروع (شامل می‌شود)
پایان: اندیس پایان (شامل نمی‌شود)
گام: گام حرکت (پیش‌فرض 1)
"""
s = 'Hello World'
print("s[1:] =", s[1:])       # → 'ello World' (از اندیس 1 تا انتها)
print("s[:3] =", s[:3])       # → 'Hel' (قبل از اندیس 3)
print("s[2:5] =", s[2:5])      # → 'llo' (از اندیس 2 تا 4)
print("s[:] =", s[:])        # → 'Hello World' (همه)
print("s[::-1] =", s[::-1])     # → 'dlroW olleH' (وارونه کردن رشته!)
print("s[::2] =", s[::2])      # → 'HloWrd' (هر دو کاراکتر یکی)

# تابع len() تعداد کاراکترها (شامل فاصله و علامت‌ها) را برمی‌گرداند.
print("len('Hello World') =", len('Hello World'))  # → 11
print("len('') =", len(''))             # → 0

# ************************************************  ویژگی‌های رشته‌ها  *************************************************
"""
رشته‌ها در پایتون غیرقابل تغییر (immutable) هستند. یعنی نمی‌توانید یک کاراکتر را مستقیماً تغییر دهید.
"""
s = 'Hello'
# s[0] = 'X'  # ❌ خطای TypeError
s1 = 'X' + s[1:]  # → 'Xello'
print("s1 =", s1)

print("'z' * 10 =", 'z' * 10)  # → 'zzzzzzzzzz'

# **************************************************  متدهای داخلی رشته (Built-in String Methods)  ********************************************
"""
متدهای داخلی رشته (Built-in String Methods)

.upper()
تمام حروف را بزرگ می‌کند

.lower()
تمام حروف را کوچک می‌کند

.capitalize()
اولین حرف را بزرگ، بقیه را کوچک می‌کند

.title()
اول هر کلمه را بزرگ می‌کند

.strip()
فاصله‌های ابتدا و انتهای رشته را حذف می‌کند

.replace(old, new)
جایگزینی رشته

.split(sep)
تقسیم رشته به لیست بر اساس جداکننده

.join(list)
الحاق لیست به رشته

.find(sub)
موقعیت اولین رخداد زیررشته را برمی‌گرداند

.startswith(prefix)
آیا با زیررشته شروع می‌شود؟

.endswith(suffix)
آیا به زیررشته ختم می‌شود؟
"""
s = "  HELLO WORLD!  "
print("s.upper() =", s.upper())               # → "  HELLO WORLD!  "
print("s.strip() =", s.strip())               # → "Hello World!"
print("s.strip().lower() =", s.strip().lower())       # → "hello world!"
print("s.split() =", s.split())               # → ['Hello', 'World!'] (با فاصله)
print("s.split('W') =", s.split('W'))            # → ['  Hello ', 'orld!  ']

print("'-'.join(['a', 'b', 'c']) =", '-'.join(['a', 'b', 'c']))  # → 'a-b-c'

print("'hello'.find('l') =", "hello".find('l'))       # → 2 (اولین موقعیت)
print("'hello'.count('l') =", "hello".count('l'))      # → 2 (تعداد تکرار)

# ******************************************************* رشته‌های خام (Raw Strings) ***********************************************
"""
رشته‌های خام (Raw Strings)
با پیشوند r می‌توان از پردازش ایسکیپ‌ها جلوگیری کرد — مفید برای مسیر فایل و عبارات منظم.
"""
path = r'C:\new\folder\file.txt'
print("path =", path)  # → C:\new\folder\file.txt (بدون تبدیل \n به خط جدید)

# هر شیء را می‌توان به رشته تبدیل کرد:
print("str(123) =", str(123))      # → '123'
print("str([1,2,3]) =", str([1,2,3]))  # → '[1, 2, 3]'

# ******************************************* سه روش اصلی قالب‌بندی رشته در پایتون ******************************************
"""
قالب‌بندی رشته‌ها در پایتون (String Formatting)
قالب‌بندی رشته‌ها به شما امکان می‌دهد که مقادیر متغیرها یا داده‌ها را مستقیماً درون یک رشته قرار دهید، 
بدون اینکه مجبور باشید از چسباندن (concatenation) یا استفاده از کاماها استفاده کنید. 
این کار کد شما را خوانا، تمیز و حرفه‌ای‌تر می‌کند.
"""
player = 'Thomas'
points = 33
print('Last night, ' + player + ' scored ' + str(points) + ' points.')  # روش قدیمی
print(f'Last night, {player} scored {points} points.')  # روش جدید

"""
سه روش اصلی قالب‌بندی رشته در پایتون
در طول زمان، سه روش برای قالب‌بندی رشته در پایتون توسعه یافته است:

% (Placeholder)
قدیمی‌ترین روش، شبیه به زبان C
قبل از Python 2

.format()
روش میانی، انعطاف‌پذیرتر
Python 2.6

f-strings
جدیدترین و سریع‌ترین روش
Python 3.6
"""

# ******************************************** قالب‌بندی با علامت درصد (%) — روش قدیمی ************************************************
"""
1. قالب‌بندی با علامت درصد (%) — روش قدیمی
از % به عنوان عملگر قالب‌بندی استفاده می‌شود. این روش شبیه به تابع printf در زبان C است.
دستورهای رایج قالب‌بندی:
%s — رشته (string)
%d — عدد صحیح (integer)
%f — عدد اعشاری (float)
%r — نمایش دقیق و خام شیء (با استفاده از repr())
"""
print("I'm going to inject %s here." % 'something')
# خروجی: I'm going to inject something here.

print("I'm going to inject %s text here, and %s text here." % ('some', 'more'))
# خروجی: I'm going to inject some text here, and more text here.

x, y = 'some', 'more'
print("I'm going to inject %s text here, and %s text here." % (x, y))

"""
تفاوت %s و %r :
%s از تابع str() استفاده می‌کند — نمایش معمولی.
%r از تابع repr() استفاده می‌کند — نمایش خام، شامل گیومه و کاراکترهای خاص.
"""
print('He said his name was %s.' % 'Fred')  # خروجی: He said his name was Fred.
print('He said his name was %r.' % 'Fred')  # خروجی: He said his name was 'Fred'.

print('I once caught a fish %s.' % 'this \tbig')  # خروجی: this     big
print('I once caught a fish %r.' % 'this \tbig')  # خروجی: 'this \\tbig'

"""
اعداد اعشاری: %5.2f
5 = حداقل عرض فیلد (کل کاراکترها)
.2 = دو رقم بعد از اعشار
f = عدد اعشاری
"""
print('Floating point numbers: %5.2f' % 13.144)   # خروجی: 13.14
print('Floating point numbers: %10.2f' % 13.144)  # خروجی:      13.14 (با فاصله)
print('Floating point numbers: %1.0f' % 13.144)   # خروجی: 13

print('First: %s, Second: %5.2f, Third: %r' % ('hi!', 3.1415, 'bye!'))
# خروجی: First: hi!, Second:  3.14, Third: 'bye!'

# ******************************************************  روش .format() — روش مدرن‌تر *************************************
"""
2. روش .format() — روش مدرن‌تر
این روش انعطاف‌پذیری بیشتری دارد و خواناتر است.
"""
print('This is a string with an {}'.format('insert'))
# خروجی: This is a string with an insert

"""
مزایای .format() نسبت به %
"""
print('The {2} {1} {0}'.format('fox', 'brown', 'quick'))
# دسترسی با اندیس
# خروجی: The quick brown fox

print('First Object: {a}, Second Object: {b}, Third Object: {c}'.format(a=1, b='Two', c=12.3))
# استفاده از نام‌های کلیدی (keywords)
# خروجی: First Object: 1, Second Object: Two, Third Object: 12.3

print('A {p} saved is a {p} earned.'.format(p='penny'))
# استفاده مجدد از متغیرها
# خروجی: A penny saved is a penny earned.

print('{0:8} | {1:9}'.format('Fruit', 'Quantity'))
print('{0:8} | {1:9}'.format('Apples', 3.))
print('{0:8} | {1:9}'.format('Oranges', 10))
# ترازبندی، پر کردن و دقت اعداد
# Fruit    | Quantity
# Apples   |       3.0
# Oranges  |        10
"""
عدد بعد از : ==> عرض فیلد
پیش‌فرض: متن چپ‌چین، عدد راست‌چین
"""

"""
ترازبندی:
< — چپ‌چین
^ — وسط‌چین
> — راست‌چین
"""
print('{0:<8} | {1:^8} | {2:>8}'.format('Left','Center','Right'))
# خروجی: Left     |  Center  |    Right

print('{0:=<8} | {1:-^8} | {2:.>8}'.format('Left','Center','Right'))  # پر کردن فضای خالی با کارکتر خاص
# خروجی: Left==== | -Center- | ...Right

print('This is my ten-character, two-decimal number:{0:10.2f}'.format(13.579))  # دقت عدد اعشاری
# خروجی:      13.58

# **************************************************  رشته‌های قالب‌بندی شده (f-strings) — روش جدید (از Python 3.6) ***********************************
"""
3. رشته‌های قالب‌بندی شده (f-strings) — روش جدید (از Python 3.6)
جدیدترین و بهترین روش، f-strings است. فقط کافیست قبل از گیومه، حرف f بگذارید و متغیرها را درون {} بنویسید.
"""
name = 'Fred'
print(f"He said his name is {name}.")
# خروجی: He said his name is Fred.

print(f"He said his name is {name!r}")  # استفاده از !r برای نمایش خام
# خروجی: He said his name is 'Fred'

"""
قالب‌بندی اعداد اعشاری در f-strings
فرمت: {value:{width}.{precision}}
"""
num = 23.45678
print(f"My 10 character, four decimal number is:{num:{10}.{6}}")
# خروجی: 23.4568
# توجه: در f-strings، precision شامل همه ارقام (قبل و بعد از اعشار) است، نه فقط اعشار.

num = 23.45
print(f"{num:10.4f}")  # ✅ درست — نتیجه:   23.4500
print(f"{num:{10}.{6}}")  # ❌ بدون پر کردن اعشار — نتیجه: 23.45

print(f"My number is: {num:10.4f}")  # بهتر است برای اعداد اعشاری از فرمت ثابت استفاده کنید

# ************************************************   ایجاد لیست (Creating Lists) ****************************************
"""
ایجاد لیست (Creating Lists)
لیست‌ها با استفاده از باقی‌مانده [] و جدا کردن عناصر با کاما (,) ایجاد می‌شوند.
"""
# لیست اعداد
numbers = [1, 2, 3, 4, 5]
print("numbers =", numbers)

# لیست رشته‌ها
names = ['Ali', 'Reza', 'Sara']
print("names =", names)

# لیست ترکیبی (انواع مختلف داده)
mixed = ['سلام', 42, 3.14, True, None]
print("mixed =", mixed)

"""
برخلاف بسیاری از زبان‌های برنامه‌نویسی، لیست‌های پایتون انعطاف‌پذیر هستند: 
اندازه آن‌ها ثابت نیست (می‌توان عناصر اضافه یا حذف کرد).
نوع داده‌های آن‌ها یکسان نباشد.
"""
# لیست خالی
empty_list = []
print("empty_list =", empty_list)
# یا
empty_list_2 = list()
print("empty_list_2 =", empty_list_2)

# *************************************************  اندیس‌گذاری و برش لیست (Indexing & Slicing)  ******************************************
"""
اندیس‌گذاری و برش لیست (Indexing & Slicing)
لیست‌ها دنباله (sequence) هستند، پس می‌توان از اندیس و برش استفاده کرد.

🔹 اندیس‌گذاری (Indexing)
اندیس از صفر شروع می‌شود.
اندیس منفی: شمارش از انتها (-1 = آخرین عنصر).
"""
my_list_3 = ['one', 'two', 'three', 4, 5]
print("my_list_3 =", my_list_3)

print("my_list_3[0] =", my_list_3[0])   # → 'one'
print("my_list_3[1] =", my_list_3[1])   # → 'two'
print("my_list_3[-1] =", my_list_3[-1])  # → 5

"""
برش لیست (Slicing)
فرمت: list[شروع:پایان:گام]

پایان شامل نیست.
پیش‌فرض: شروع=0، پایان=اندازه، گام=1.
"""
print("my_list_3[1:] =", my_list_3[1:])     # → ['two', 'three', 4, 5]
print("my_list_3[:3] =", my_list_3[:3])     # → ['one', 'two', 'three']
print("my_list_3[1:4] =", my_list_3[1:4])    # → ['two', 'three', 4]
print("my_list_3[::2] =", my_list_3[::2])    # → ['one', 'three', 5] (هر دو تا یکی)
print("my_list_3[::-1] =", my_list_3[::-1])   # → [5, 4, 'three', 'two', 'one'] (وارونه)

# طول لیست — len()
print("len([1, 2, 3]) =", len([1, 2, 3]))  # → 3
print("len([]) =", len([]))         # → 0

# *************************************************************  عملیات ریاضی روی لیست‌ها  ****************************
"""
عملیات ریاضی روی لیست‌ها:

[1, 2] + [3, 4]  # → [1, 2, 3, 4]

این عمل تغییر دائمی ایجاد نمی‌کند، مگر اینکه نتیجه را دوباره به متغیر اختصاص دهید: 
my_list = ['one', 'two']
my_list = my_list + ['three']  # تغییر دائمی

['A'] * 3  # → ['A', 'A', 'A']
[1, 2] * 2 # → [1, 2, 1, 2]
"""
print("[1, 2] + [3, 4] =", [1, 2] + [3, 4])  # → [1, 2, 3, 4]
print("['A'] * 3 =", ['A'] * 3)  # → ['A', 'A', 'A']
print("[1, 2] * 2 =", [1, 2] * 2) # → [1, 2, 1, 2]

# ***********************************************************  متدهای پرکاربرد لیست  ******************************
"""
متدهای پرکاربرد لیست
لیست‌ها دارای متدهای داخلی زیادی هستند که به صورت درجا (in-place) عمل می‌کنند (یعنی خود لیست را تغییر می‌دهند و None برمی‌گردانند).

.append(item)
عنصر را به انتهای لیست اضافه می‌کند

.pop([index])
عنصر را از لیست حذف و برمی‌گرداند (پیش‌فرض آخرین عنصر)

.remove(value)
اولین عنصر با مقدار مشخص را حذف می‌کند

.insert(index, item)
عنصر را در موقعیت مشخص وارد می‌کند

.extend(iterable)
عناصر یک سری را به انتهای لیست اضافه می‌کند

.sort()
لیست را به صورت صعودی مرتب می‌کند

.reverse()
ترتیب عناصر را معکوس می‌کند

.clear()
تمام عناصر را حذف می‌کند

.copy()
یک کپی سطحی از لیست برمی‌گرداند
"""
my_list_4 = [1, 2, 3]
print("my_list_4 =", my_list_4)

# اضافه کردن
my_list_4.append('append me!')
print("my_list_4 after append =", my_list_4)
# → [1, 2, 3, 'append me!']

# حذف و بازگرداندن عنصر
popped = my_list_4.pop()       # → 'append me!'
print("popped item =", popped)
popped = my_list_4.pop(0)      # → 1
print("popped item at index 0 =", popped)

# اضافه کردن در موقعیت خاص
my_list_4.insert(1, 'inserted')
print("my_list_4 after insert =", my_list_4)
# → [2, 'inserted', 3]

# حذف بر اساس مقدار
my_list_4.remove('inserted')
print("my_list_4 after remove =", my_list_4)

# الحاق چند عنصر
my_list_4.extend([4, 5, 6])
print("my_list_4 after extend =", my_list_4)
# → [2, 3, 4, 5, 6]

# مرتب‌سازی
new_list = ['c', 'a', 'e', 'b']
print("new_list =", new_list)
new_list.sort()
print("new_list after sort =", new_list)    # → ['a', 'b', 'c', 'e']
new_list.reverse()
print("new_list after reverse =", new_list) # → ['e', 'c', 'b', 'a']

"""
متدهایی مثل .sort() و .reverse() خود لیست را تغییر می‌دهند و None برمی‌گردانند.
اگر بخواهید لیست اصلی تغییر نکند، از توابع sorted() و reversed() استفاده کنید: 
"""
my_list_4 = [2, 3, 4, 5, 6]  # بازنشانی لیست
print("sorted(my_list_4) =", sorted(my_list_4))        # لیست جدید مرتب شده
print("list(reversed(my_list_4)) =", list(reversed(my_list_4))) # لیست جدید معکوس

# *******************************************************  خطاهای رایج  *******************************************
"""
خطاهای رایج
اندیس خارج از محدوده

my_list = [1, 2, 3]
my_list[100]  # → IndexError: list index out of range

تغییر لیست در حین پیمایش 
خطرناک!
for item in my_list:
    if item == 2:
        my_list.remove(item)  # ممکن است باعث نادیده گرفتن عناصر شود

✅ راه‌حل: از کپی یا لیست جدید استفاده کنید. 
"""
# ************************************************* تو در تو بودن لیست‌ها (Nesting Lists) *************************************
"""
تو در تو بودن لیست‌ها (Nesting Lists)
لیست‌ها می‌توانند حاوی لیست‌های دیگر باشند. 
این ویژگی برای ساختارهای چندبعدی مثل ماتریس‌ها بسیار مفید است.
"""
# سه لیست
lst_1 = [1, 2, 3]
lst_2 = [4, 5, 6]
lst_3 = [7, 8, 9]

# ماتریس
matrix = [lst_1, lst_2, lst_3]
print("matrix =", matrix)

# دسترسی
print("matrix[0] =", matrix[0])       # → [1, 2, 3]
print("matrix[0][0] =", matrix[0][0])    # → 1 (اولین سطر، اولین ستون)
print("matrix[1][2] =", matrix[1][2])    # → 6 (دومین سطر، سومین ستون)

# **************************************************  لیست تفکیکی (List Comprehensions) ********************************************
"""
لیست تفکیکی (List Comprehensions)
یکی از قدرتمندترین ویژگی‌های پایتون است که به شما امکان می‌دهد لیست‌ها را به صورت خلاصه و کارآمد بسازید.
لیست تفکیکی جایگزین تمیز و کوتاهی برای حلقه‌های for طولانی است.
"""
# اعداد 0 تا 4
print("[x for x in range(5)] =", [x for x in range(5)])  # → [0, 1, 2, 3, 4]

# مجذور اعداد
print("[x**2 for x in range(5)] =", [x**2 for x in range(5)])  # → [0, 1, 4, 9, 16]

# فقط اعداد زوج
print("[x for x in range(10) if x % 2 == 0] =", [x for x in range(10) if x % 2 == 0])  # → [0, 2, 4, 6, 8]

# ترکیب با if و else
print("['even' if x % 2 == 0 else 'odd' for x in range(5)] =", ['even' if x % 2 == 0 else 'odd' for x in range(5)])
# → ['even', 'odd', 'even', 'odd', 'even']

# مثال ماتریس: استخراج ستون اول
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
first_col = [row[0] for row in matrix]  # → [1, 4, 7]
print("first_col =", first_col)

# *****************************************  کپی لیست — سطحی در مقابل عمیق  **********************************************
"""
کپی لیست — سطحی در مقابل عمیق
چون لیست‌ها قابل تغییر هستند، باید مراقب باشید که فقط "ارجاع" (reference) کپی نشود.
"""
# کپی سطحی با =
a = [1, 2, 3]
b = a         # b به همان لیست اشاره می‌کند
b[0] = 99
print("a after b[0] = 99:", a)      # → [99, 2, 3] — تغییر در a!

# راه‌های ایجاد کپی واقعی
# روش 1: سایلینگ
b = a[:]
print("b = a[:] => b =", b)

# روش 2: متد copy()
b = a.copy()
print("b = a.copy() => b =", b)

# روش 3: تابع list()
b = list(a)
print("b = list(a) => b =", b)

# روش 4: ماژول copy (برای کپی عمیق)
import copy
b = copy.deepcopy(a)  # برای لیست‌های تو در تو
print("b = copy.deepcopy(a) => b =", b)

# ************************************************ ایجاد دیکشنری (Constructing a Dictionary) ***************************************************
"""
ایجاد دیکشنری (Constructing a Dictionary)
دیکشنری با استفاده از آکولاد {} و جفت‌های کلید: مقدار ساخته می‌شود.
"""
my_dict = {'name': 'Ali', 'age': 25, 'city': 'Tehran'}
print("my_dict =", my_dict)

"""
کلیدها باید hashable باشند (معمولاً str, int, tuple، نه list یا dict).
مقادیر می‌توانند هر نوع داده‌ای باشند (حتی دیکشنری دیگر!).
"""

"""
انواع روش‌های ساخت دیکشنری:
لیترال
{'a': 1, 'b': 2}

تابع dict()
dict(a=1, b=2)
یا
dict([('a', 1), ('b', 2)])

دیکشنری تفکیکی (Comprehension)
{x: x**2 for x in range(3)}
→
{0: 0, 1: 1, 2: 4}
"""
print("dict(a=1, b=2) =", dict(a=1, b=2))
print("dict([('a', 1), ('b', 2)]) =", dict([('a', 1), ('b', 2)]))
print("{x: x**2 for x in range(3)} =", {x: x**2 for x in range(3)})

# *************************************************************  دسترسی به مقادیر (Accessing Values)  ****************************
# دسترسی به مقادیر (Accessing Values)
my_dict = {'key1': 123, 'key2': [12, 23, 33], 'key3': ['a', 'b', 'c']}
print("my_dict =", my_dict)
print("my_dict['key1'] =", my_dict['key1'])        # → 123
print("my_dict['key3'][1] =", my_dict['key3'][1])     # → 'b'
print("my_dict['key3'][1].upper() =", my_dict['key3'][1].upper())  # → 'B'

# استفاده از .get() (ایمن‌تر)
# اگر کلید وجود نداشته باشد، با [] خطای KeyError می‌گیرید. اما .get() این مشکل را حل می‌کند:
print("my_dict.get('key4') =", my_dict.get('key4'))           # → None
print("my_dict.get('key4', 'Not Found') =", my_dict.get('key4', 'Not Found'))  # → 'Not Found'

# ****************************************************  تغییر و افزودن عناصر ***********************************************
"""
تغییر و افزودن عناصر
دیکشنری‌ها قابل تغییر (mutable) هستند.

افزودن یا تغییر مقدار:
"""
d = {}
d['animal'] = 'Dog'      # اضافه کردن
print("d after adding 'animal':", d)
d['answer'] = 42         # اضافه کردن
print("d after adding 'answer':", d)
d['animal'] = 'Cat'      # تغییر مقدار
print("d after changing 'animal':", d)

# عملگرهای ترکیبی (+=, -= و غیره):
d = {'score': 100}
print("d =", d)
d['score'] -= 20         # → 80
print("d after d['score'] -= 20:", d)

# ******************************************************  تو در تو بودن دیکشنری‌ها (Nesting) ******************************************
"""
تو در تو بودن دیکشنری‌ها (Nesting)
دیکشنری‌ها می‌توانند حاوی دیکشنری‌های دیگر، لیست‌ها یا ترکیبی از آن‌ها باشند.

d = {
    'key1': {
        'nestkey': {
            'subnestkey': 'value'
        }
    }
}
d['key1']['nestkey']['subnestkey']  # → 'value'
"""
users = {
    'Ali': {
        'age': 30,
        'skills': ['Python', 'Django'],
        'active': True
    },
    'Sara': {
        'age': 25,
        'skills': ['JavaScript', 'React'],
        'active': False
    }
}
print("users =", users)

print("users['Ali']['skills'][0] =", users['Ali']['skills'][0])  # → 'Python'

# ****************************************************** متدهای مهم دیکشنری *************************************************
"""
متدهای مهم دیکشنری:

.keys()
بازگرداندن کلیدها

.values()
بازگرداندن مقادیر

.items()
بازگرداندن جفت‌های (کلید, مقدار)

.get(key, default)
گرفتن مقدار با مقدار پیش‌فرض

.pop(key)
حذف و بازگرداندن مقدار

.popitem()
حذف و بازگرداندن آخرین جفت (از نسخه 3.7: LIFO)

.update(dict)
به‌روزرسانی با دیکشنری دیگر

.setdefault(key, default)
اگر کلید نباشد، اضافه کن

.clear()
پاک کردن تمام عناصر

.copy()
کپی سطحی
"""

d = {'a': 1, 'b': 2, 'c': 3}
print("d =", d)

print("d.keys() =", d.keys())     # → dict_keys(['a', 'b', 'c'])
print("d.values() =", d.values())   # → dict_values([1, 2, 3])
print("d.items() =", d.items())    # → dict_items([('a', 1), ('b', 2), ('c', 3)])

# به‌روزرسانی
d.update({'d': 4, 'e': 5})
print("d after update =", d)

# حذف
popped_value = d.pop('a')   # → 1
print("popped value =", popped_value)
print("d after pop =", d)

# ********************************************************  نمای‌های دیکشنری (Dictionary Views) **************************************
"""
نمای‌های دیکشنری (Dictionary Views)
متدهای .keys(), .values(), و .items() نمای پویا (dynamic view) برمی‌گردانند — یعنی اگر دیکشنری تغییر کند،
نمای آن هم تغییر می‌کند.
"""

d = {'x': 1, 'y': 2}
keys = d.keys()
print("keys before adding 'z':", keys)
d['z'] = 3
print("keys after adding 'z':", keys)  # → dict_keys(['x', 'y', 'z']) — به‌روز شد!

"""
ویژگی‌های نمای‌ها:
پویا: با تغییر دیکشنری، تغییر می‌کنند.
قابل تکرار: می‌توان با for روی آن‌ها حلقه زد.
قابلیت عملیات مجموعه‌ای (برای .keys() و .items()):
"""
d1 = {'a': 1, 'b': 2}
d2 = {'b': 3, 'c': 4}
print("d1 =", d1)
print("d2 =", d2)

print("d1.keys() & d2.keys() =", d1.keys() & d2.keys())  # → {'b'} (اشتراک)
print("d1.keys() | d2.keys() =", d1.keys() | d2.keys())  # → {'a', 'b', 'c'} (اتحاد)
# .values() عملیات مجموعه‌ای ندارد چون مقادیر ممکن است تکراری باشند.

# ******************************************************* نکات مهم درباره دیکشنری‌ها **********************************************
"""
از پایتون 3.7 به بعد، دیکشنری‌ها ترتیب درج (insertion order) را حفظ می‌کنند.
که در نسخه‌های قدیمی تضمین نشده بود.
"""

"""
کلیدهای معتبر
کلیدها باید غیرقابل تغییر (immutable) باشند.
✅ مجاز: str, int, tuple (اگر عناصرش immutable باشند)
❌ غیرمجاز: list, dict, set
"""
valid = {('a', 'b'): 1}     # ✅
print("valid =", valid)
# invalid = {['a', 'b']: 1}   # ❌ TypeError

"""
دو دیکشنری برابر هستند اگر همه جفت‌های کلید-مقدار آن‌ها برابر باشند 
(ترتیب مهم نیست، اما از 3.7 به بعد ترتیب درج حفظ می‌شود).
"""
print("{'a': 1, 'b': 2} == {'b': 2, 'a': 1}:", {'a': 1, 'b': 2} == {'b': 2, 'a': 1})  # → True

# *****************************************************  منابع و مراجع  ***********************************************
"""
برای مطالعه و یادگیری بیشتر :

https://docs.python.org/3/library/stdtypes.html?spm=a2ty_o01.29997173.0.0.50adc921tqvL7P#old-string-formatting
https://docs.python.org/3/library/string.html?spm=a2ty_o01.29997173.0.0.50adc921tqvL7P#formatstrings
https://docs.python.org/3/reference/lexical_analysis.html?spm=a2ty_o01.29997173.0.0.50adc921tqvL7P#f-strings
"""
